package exchangemage.effects.targeting;

import java.util.Set;

import exchangemage.effects.base.Effect;
import exchangemage.effects.base.EffectPlayer;

/**
 * An abstract base class for all classes used to select a target for an {@link Effect}. Its two
 * most important methods are:
 * <ul>
 *     <li>{@link #getActiveTargetables} which returns a set of all {@link Targetable} objects that
 *     can potentially be selected by a given selector.</li>
 *     <li>{@link #chooseTarget} which chooses a target for the {@link Effect} from the set of
 *     active targetables provided by the {@link TargetingManager} (based on the set generated by
 *     the {@link #getActiveTargetables} method).</li>
 * </ul>
 * TargetSelector methods are called by the {@link TargetingManager} in the process of selecting
 * a target for an effect being enqueued into the resolution queue of the {@link EffectPlayer}.
 *
 * @see Effect
 * @see EffectPlayer
 * @see Targetable
 * @see TargetingManager
 */
public abstract class TargetSelector {
    /**
     * The {@link Targetable} object selected by this {@link TargetSelector} as the target for its
     * {@link Effect}.
     */
    private Targetable target;

    /**
     * Returns a set of all {@link Targetable} objects that can potentially be selected by this
     * {@link TargetSelector} as the target for its {@link Effect}.
     * <br><br>
     * This method is called by the {@link TargetingManager} to create a set
     * of active targetables when this selector is set as the manager's current, active selector.
     *
     * @return a set of all {@link Targetable} objects that can potentially be selected as an
     * effect's target by this selector.
     *
     * @see Targetable
     * @see TargetingManager
     * @see Effect
     */
    public abstract Set<Targetable> getActiveTargetables();

    /**
     * Chooses a target for this selector's {@link Effect} from the set of active
     * {@link Targetable}s provided by the {@link TargetingManager}. Return value indicates
     * whether it was possible to select a valid target.
     *
     * @param activeTargetables the set of active targetables to choose from.
     * @return <code>true</code> if a target has been successfully selected, <code>false</code>
     * otherwise.
     *
     * @see Targetable
     * @see TargetingManager
     * @see Effect
     */
    public abstract boolean chooseTarget(Set<Targetable> activeTargetables);

    /**
     * Returns whether a target has been selected.
     *
     * @return <code>true</code> if a target has been selected, <code>false</code> otherwise.
     *
     * @see Targetable
     */
    public boolean hasTarget() { return target != null; }

    /**
     * Sets the target to the given {@link Targetable} object.
     *
     * @param target the target to set.
     *
     * @see Targetable
     */
    public void setTarget(Targetable target) {
        if (target == null)
            throw new IllegalArgumentException("Cannot set null target.");
        this.target = target;
    }

    /**
     * Returns the selected target.
     *
     * @return the target selected by this {@link TargetSelector}.
     *
     * @throws IllegalStateException if no target has been selected.
     *
     * @see Targetable
     */
    public Targetable getTarget() {
        if (!this.hasTarget())
            throw new IllegalStateException("No target has been selected.");
        return this.target;
    }
}
