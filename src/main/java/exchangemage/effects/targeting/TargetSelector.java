package exchangemage.effects.targeting;

import java.util.Objects;
import java.util.Set;

import exchangemage.effects.base.Effect;
import exchangemage.effects.base.EffectPlayer;

/**
 * An abstract base class for all classes used to select a target for an {@link Effect}. Its two
 * most important methods are:
 * <ul>
 *     <li>{@link #getActiveTargetables} which returns a set of all {@link Targetable} objects that
 *     can potentially be selected by a given selector.</li>
 *     <li>{@link #selectTarget} which chooses a target for the {@link Effect} from a set of
 *     active targetables provided by the {@link TargetingManager} (based on the set generated by
 *     the {@link #getActiveTargetables} method).</li>
 * </ul>
 * TargetSelector methods are called by the {@link TargetingManager} in the process of selecting
 * a target for an effect being evaluated by the {@link EffectPlayer}.
 *
 * @param <T> the type of {@link Targetable} objects which can be selected by a given target
 * selector
 * @see Effect
 * @see EffectPlayer
 * @see Targetable
 * @see TargetingManager
 */
public abstract class TargetSelector<T extends Targetable> {
    /**
     * The {@link Targetable} object selected by this {@link TargetSelector} as the target for its
     * {@link Effect}.
     */
    protected T target;

    /**
     * The class of the {@link Targetable} objects selected by this {@link TargetSelector}.
     */
    private final Class<T> targetClass;

    /**
     * Creates a new {@link TargetSelector} with given target class.
     *
     * @param targetClass the class of the {@link Targetable} objects selected by this selector.
     * @throws NullPointerException if the given target class is <code>null</code>.
     */
    public TargetSelector(Class<T> targetClass) {
        Objects.requireNonNull(targetClass, "Target class cannot be null.");
        this.targetClass = targetClass;
    }

    /**
     * An exception thrown when an attempt is made to set an invalid target for a
     * {@link TargetSelector} or to select a target from an invalid set of {@link Targetable}s.
     *
     * @see TargetSelector
     * @see Targetable
     */
    public static class InvalidTargetException extends IllegalArgumentException {
        public InvalidTargetException(String message) {super(message);}
    }

    /**
     * Returns a set of all {@link Targetable} objects that can potentially be selected by this
     * {@link TargetSelector} as the target for its {@link Effect}.
     * <br><br>
     * This method is called by the {@link TargetingManager} to create a set
     * of active targetables when this selector is set as the manager's active selector.
     *
     * @return a set of all {@link Targetable} objects that can potentially be selected as an
     * effect's target by this selector.
     * @see Targetable
     * @see TargetingManager
     * @see Effect
     */
    public abstract Set<T> getActiveTargetables();

    /**
     * Chooses a target for this selector's {@link Effect} from the set of active
     * {@link Targetable}s provided by the {@link TargetingManager}. Return value indicates
     * whether it was possible to select a valid target.
     *
     * @param activeTargetables the set of active targetables to choose from.
     * @return <code>true</code> if a target has been successfully selected, <code>false</code>
     * otherwise.
     * @see Targetable
     * @see TargetingManager
     * @see Effect
     */
    public abstract boolean selectTarget(Set<Targetable> activeTargetables);

    /**
     * Validates given {@link Targetable} object as a target for this {@link TargetSelector}.
     * Called to ensure validity when the {@link #setTarget} method is used instead of the standard
     * target selection process.
     * <br><br>
     * Concrete implementations of the TargetSelector base class should override this method to
     * provide their own validation logic.
     *
     * @param target the target to validate.
     * @throws InvalidTargetException if the given target is null.
     */
    protected abstract void validateTarget(T target);

    /**
     * Returns whether this {@link TargetSelector} has a selected target.
     *
     * @return <code>true</code> if a target has been selected, <code>false</code> otherwise.
     * @see Targetable
     */
    public boolean hasTarget() {return target != null;}

    /**
     * Sets this {@link TargetSelector}'s target to the given {@link Targetable} object if it
     * is valid (checked by the {@link #validateTarget} method).
     *
     * @param target the target to set.
     * @see Targetable
     */
    public void setTarget(Targetable target) {
        if (target == null)
            throw new InvalidTargetException("Target cannot be null.");
        if (!targetClass.isInstance(target))
            throw new InvalidTargetException(
                    "Target must be of type " + targetClass.getName() + "."
            );
        validateTarget(targetClass.cast(target));
        this.target = targetClass.cast(target);
    }

    /**
     * Returns the selected target.
     *
     * @return the target selected by this {@link TargetSelector}.
     * @throws IllegalStateException if no target has been selected.
     * @see Targetable
     */
    public T getTarget() {
        if (!this.hasTarget())
            throw new IllegalStateException("No target has been selected.");
        return this.target;
    }
}
